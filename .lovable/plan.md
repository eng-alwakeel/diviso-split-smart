

# إصلاح مشكلة تكرار الفئات (111 فئة بدل ~70)

## المشكلة
في قاعدة البيانات **116 فئة**، لكن الأسماء الفريدة فقط **70**. يعني **46 فئة مكررة**!

مثال على التكرار:
- "مصاريف متنوعة" = **13 نسخة**
- "طوارئ" = **12 نسخة**
- "أساسيات" = **5 نسخ**
- "المواصلات" = **5 نسخ**

## السبب الجذري
يوجد **4 أماكن** في الكود تُنشئ فئات بدون التحقق من وجودها مسبقاً:

1. **`useCategories.ts`** → `insertCategory()` — يدخل مباشرة بدون أي تحقق
2. **`useBudgetFromAI.ts`** → يدخل فئة جديدة إذا `is_new_category` بدون تحقق
3. **`useAIGroupSuggestions.ts`** → نفس المشكلة عند إنشاء فئات من اقتراحات AI
4. **`CreateUnifiedBudget.tsx`** → فيه تحقق (`maybeSingle`) لكن يبحث بالاسم فقط بدون فلتر المستخدم

بالإضافة إلى ذلك:
- `fetchCategories()` في `useCategories.ts` يجلب **كل** الفئات بدون فلتر — فكل مستخدم يرى فئات كل المستخدمين الآخرين

## خطة الإصلاح

### المرحلة 1 — تنظيف قاعدة البيانات (حذف المكرر)
- كتابة SQL لحذف الفئات المكررة مع الحفاظ على أقدم نسخة من كل اسم
- تحديث أي `expenses.category_id` أو `budget_categories.category_id` يشير للنسخ المحذوفة ليشير للنسخة الأصلية
- النتيجة: من 116 فئة إلى ~70 فئة

### المرحلة 2 — منع التكرار مستقبلاً في الكود

**ملف `useCategories.ts`:**
- تعديل `insertCategory` للتحقق من وجود فئة بنفس الاسم قبل الإدخال
- إذا موجودة يرجع الموجودة بدل إنشاء جديدة

**ملف `useBudgetFromAI.ts`:**
- إضافة بحث بالاسم قبل `insert` حتى لو `is_new_category = true`

**ملف `useAIGroupSuggestions.ts`:**
- نفس المنطق: بحث بالاسم أولاً، وإذا موجودة يستخدم الموجودة

**ملف `CreateUnifiedBudget.tsx`:**
- الملف فيه تحقق بالفعل لكن بدون `created_by` filter — يُبقى كما هو (صحيح)

### المرحلة 3 — فلترة العرض
**ملف `useCategories.ts`:**
- تعديل `fetchCategories` لعرض الفئات الافتراضية (`created_by IS NULL`) + فئات المستخدم الحالي فقط
- أو الاحتفاظ بعرض الكل لكن مع إزالة المكرر بالاسم (deduplicate)

### المرحلة 4 — إضافة قيد في قاعدة البيانات
- إضافة unique constraint على `(name_ar)` في جدول `categories` لمنع التكرار نهائياً على مستوى قاعدة البيانات

## التأثير المتوقع
- الفئات تنخفض من 116 إلى ~70
- لن يظهر "أساسيات" 5 مرات في القائمة
- أي إضافة مستقبلية ستتحقق أولاً قبل الإنشاء

